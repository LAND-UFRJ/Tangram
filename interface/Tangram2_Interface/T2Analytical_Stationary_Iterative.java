/*
 * Copyright (C) 1999-2009, Edmundo Albuquerque de Souza e Silva.
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined by Trolltech AS of Norway and appearing in the file
 * LICENSE.QPL included in the packaging of this file.
 *
 * THIS FILE IS PROVIDED AS IS WITH NO WARRANTY OF ANY KIND, INCLUDING
 * THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

package Tangram2;

public class T2Analytical_Stationary_Iterative extends javax.swing.JPanel {

  /** Initializes the Form */
  public T2Analytical_Stationary_Iterative(T2modelenv ModelEnv) {
    modelenv = ModelEnv;
    initComponents ();
    initComponentsManual ();
  }


  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the FormEditor.
   */
private void initComponents () {//GEN-BEGIN:initComponents
    jP_Iterative_Methods = new javax.swing.JPanel ();
    jL_Iterative_Precision = new javax.swing.JLabel ();
    jTF_Iterative_Precision = new javax.swing.JTextField ();
    jTB_Power = new javax.swing.JToggleButton ();
    jTB_Gauss_Siedel = new javax.swing.JToggleButton ();
    jTB_Jacobi = new javax.swing.JToggleButton ();
    jTB_SOR = new javax.swing.JToggleButton ();
    jL_Power = new javax.swing.JLabel ();
    jL_Gauss_Siedel = new javax.swing.JLabel ();
    jL_Jacobi = new javax.swing.JLabel ();
    jL_SOR = new javax.swing.JLabel ();
    jL_Max_Iterations = new javax.swing.JLabel ();
    jTF_Max_Iterations = new javax.swing.JTextField ();
    setLayout (new org.netbeans.lib.awtextra.AbsoluteLayout ());

    jP_Iterative_Methods.setLayout (new org.netbeans.lib.awtextra.AbsoluteLayout ());
    jP_Iterative_Methods.setBorder (new javax.swing.border.LineBorder(java.awt.Color.gray));

      jL_Iterative_Precision.setText ("Precision");
      jL_Iterative_Precision.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_Iterative_Precision, new org.netbeans.lib.awtextra.AbsoluteConstraints (180, 60, -1, -1));
  
      jTF_Iterative_Precision.setToolTipText ("Error bound");
  
      jP_Iterative_Methods.add (jTF_Iterative_Precision, new org.netbeans.lib.awtextra.AbsoluteConstraints (350, 55, 100, 20));
  
      jTB_Power.setSelected (true);
  
      jP_Iterative_Methods.add (jTB_Power, new org.netbeans.lib.awtextra.AbsoluteConstraints (11, 18, 15, 15));
  
  
      jP_Iterative_Methods.add (jTB_Gauss_Siedel, new org.netbeans.lib.awtextra.AbsoluteConstraints (11, 48, 15, 15));
  
  
      jP_Iterative_Methods.add (jTB_Jacobi, new org.netbeans.lib.awtextra.AbsoluteConstraints (11, 78, 15, 15));
  
  
      jP_Iterative_Methods.add (jTB_SOR, new org.netbeans.lib.awtextra.AbsoluteConstraints (11, 108, 15, 15));
  
      jL_Power.setText ("Power");
      jL_Power.setForeground (java.awt.Color.black);
      jL_Power.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_Power, new org.netbeans.lib.awtextra.AbsoluteConstraints (30, 18, -1, 17));
  
      jL_Gauss_Siedel.setText ("Gauss-Siedel");
      jL_Gauss_Siedel.setForeground (java.awt.Color.black);
      jL_Gauss_Siedel.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_Gauss_Siedel, new org.netbeans.lib.awtextra.AbsoluteConstraints (30, 48, -1, 17));
  
      jL_Jacobi.setText ("Jacobi");
      jL_Jacobi.setForeground (java.awt.Color.black);
      jL_Jacobi.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_Jacobi, new org.netbeans.lib.awtextra.AbsoluteConstraints (30, 78, -1, 17));
  
      jL_SOR.setText ("SOR");
      jL_SOR.setForeground (java.awt.Color.black);
      jL_SOR.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_SOR, new org.netbeans.lib.awtextra.AbsoluteConstraints (30, 108, -1, 17));
  
      jL_Max_Iterations.setText ("Max number of iterations");
      jL_Max_Iterations.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Iterative_Methods.add (jL_Max_Iterations, new org.netbeans.lib.awtextra.AbsoluteConstraints (180, 85, -1, -1));
  
      jTF_Max_Iterations.setToolTipText ("Abort execution when this number is reached.");
      jTF_Max_Iterations.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
              jTF_Max_IterationsActionPerformed (evt);
          }
      }
      );
  
      jP_Iterative_Methods.add (jTF_Max_Iterations, new org.netbeans.lib.awtextra.AbsoluteConstraints (350, 80, 100, 20));
  

    add (jP_Iterative_Methods, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 10, 550, 150));

}//GEN-END:initComponents

  private void jTF_Max_IterationsActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTF_Max_IterationsActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_jTF_Max_IterationsActionPerformed

  private void initComponentsManual()
  {
    javax.swing.ButtonGroup group = new javax.swing.ButtonGroup();
    group.add(jTB_Power);
    group.add(jTB_Gauss_Siedel);
    group.add(jTB_Jacobi);
    group.add(jTB_SOR);
  }

  public void Evaluate()
  {
    String command;

    command = "";

    if (T2functions.Is_some_field_missing(jP_Iterative_Methods))
      return;

    if (!T2functions.Is_Precision_valid(jTF_Iterative_Precision.getText(),this))
      return;

    if (T2functions.Is_not_number(jTF_Max_Iterations.getText(),1,this,"Max number of iterations") != 0)
      return;

    if (jTB_Power.isSelected()) {
        command = "solv " + modelenv.curmodel + " 4 " + jTF_Iterative_Precision.getText()
                  + " " + jTF_Max_Iterations.getText();     //Power Method was selected
    }
    else if (jTB_Gauss_Siedel.isSelected()) {
        command = "solv " + modelenv.curmodel + " 1 " + jTF_Iterative_Precision.getText()
                  + " " + jTF_Max_Iterations.getText();     //Gauss-Siedel Method was selected
    }
    else if (jTB_Jacobi.isSelected()) {
        command = "solv " + modelenv.curmodel + " 2 " + jTF_Iterative_Precision.getText()
                  + " " + jTF_Max_Iterations.getText();     //Jacobi Method was selected
    }
    else if (jTB_SOR.isSelected()) {
        command = "solv " + modelenv.curmodel + " 3 " + jTF_Iterative_Precision.getText()
                  + " " + jTF_Max_Iterations.getText();     //SOR Method was selected
    }

   //call solv program
    modelenv.analytical.setEnabled(false);
    status = new T2status( modelenv.analytical, "Solver Status", "Solv is running", command, 0 ,(modelenv.outputdevice ? modelenv.fileout : modelenv.outputscreen), (modelenv.outputdevice ? modelenv.fileout : modelenv.outputscreen));
    status.show();
    status.start();
 }

  public String Get_Method_Name() {
    return "Iterative";
  }

  public void KillChild()
  {
    if (status != null) {
      status.Proc.destroy();
      status.dispose();
    }
  }


// Variables declaration - do not modify//GEN-BEGIN:variables
private javax.swing.JPanel jP_Iterative_Methods;
private javax.swing.JLabel jL_Iterative_Precision;
private javax.swing.JTextField jTF_Iterative_Precision;
private javax.swing.JToggleButton jTB_Power;
private javax.swing.JToggleButton jTB_Gauss_Siedel;
private javax.swing.JToggleButton jTB_Jacobi;
private javax.swing.JToggleButton jTB_SOR;
private javax.swing.JLabel jL_Power;
private javax.swing.JLabel jL_Gauss_Siedel;
private javax.swing.JLabel jL_Jacobi;
private javax.swing.JLabel jL_SOR;
private javax.swing.JLabel jL_Max_Iterations;
private javax.swing.JTextField jTF_Max_Iterations;
// End of variables declaration//GEN-END:variables
  private T2modelenv modelenv;
  private T2status status;
}
