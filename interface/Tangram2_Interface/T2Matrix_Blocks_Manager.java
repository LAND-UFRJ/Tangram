/*
 * Copyright (C) 1999-2009, Edmundo Albuquerque de Souza e Silva.
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined by Trolltech AS of Norway and appearing in the file
 * LICENSE.QPL included in the packaging of this file.
 *
 * THIS FILE IS PROVIDED AS IS WITH NO WARRANTY OF ANY KIND, INCLUDING
 * THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

package Tangram2;

public class T2Matrix_Blocks_Manager extends javax.swing.JPanel {

  /** Initializes the Form */
  public T2Matrix_Blocks_Manager(String cdir, String cmodel) {
    curdir = cdir; curmodel = cmodel;

    initComponents ();

    initComponentsManual();

  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the FormEditor.
   */
private void initComponents () {//GEN-BEGIN:initComponents
    jP_Block_Set = new javax.swing.JPanel ();
    jL_Initial_State = new javax.swing.JLabel ();
    jL_Block_Size = new javax.swing.JLabel ();
    jB_Add = new javax.swing.JButton ();
    jL_Quantity = new javax.swing.JLabel ();
    jB_Remove = new javax.swing.JButton ();
    jB_RemoveAll = new javax.swing.JButton ();
    jTF_Initial_State = new javax.swing.JTextField ();
    jTF_Block_Size = new javax.swing.JTextField ();
    jTF_Quantity = new javax.swing.JTextField ();
    jScrollPane1 = new javax.swing.JScrollPane ();
    jTable = new javax.swing.JTable ();
    jL_Block = new javax.swing.JLabel ();
    jLabel1 = new javax.swing.JLabel ();
    jLabel2 = new javax.swing.JLabel ();
    jL_Total_States = new javax.swing.JLabel ();
    jPB_Covered_States = new javax.swing.JProgressBar ();
    setLayout (new org.netbeans.lib.awtextra.AbsoluteLayout ());

    jP_Block_Set.setLayout (new org.netbeans.lib.awtextra.AbsoluteLayout ());
    jP_Block_Set.setBorder (new javax.swing.border.TitledBorder(
    new javax.swing.border.EtchedBorder(), " Block Set ", 1, 2,
    new java.awt.Font ("Dialog", 1, 10)));
    jP_Block_Set.setForeground (new java.awt.Color (102, 102, 153));
    jP_Block_Set.setEnabled (false);

      jL_Initial_State.setText ("Initial State");
      jL_Initial_State.setForeground (java.awt.Color.black);
      jL_Initial_State.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Block_Set.add (jL_Initial_State, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 20, -1, 20));
  
      jL_Block_Size.setText ("Block Size");
      jL_Block_Size.setForeground (java.awt.Color.black);
      jL_Block_Size.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Block_Set.add (jL_Block_Size, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 50, 80, 20));
  
      jB_Add.setToolTipText ("Add block set to partition definition");
      jB_Add.setFont (new java.awt.Font ("Dialog", 0, 10));
      jB_Add.setText ("Add");
      jB_Add.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
              jB_AddActionPerformed (evt);
          }
      }
      );
  
      jP_Block_Set.add (jB_Add, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 110, 130, 20));
  
      jL_Quantity.setText ("Quantity");
      jL_Quantity.setForeground (java.awt.Color.black);
      jL_Quantity.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jP_Block_Set.add (jL_Quantity, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 80, -1, 20));
  
      jB_Remove.setToolTipText ("Remove block definition");
      jB_Remove.setFont (new java.awt.Font ("Dialog", 0, 10));
      jB_Remove.setText ("Remove");
      jB_Remove.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
              jB_RemoveActionPerformed (evt);
          }
      }
      );
  
      jP_Block_Set.add (jB_Remove, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 135, 130, 20));
  
      jB_RemoveAll.setToolTipText ("Remove all blocks");
      jB_RemoveAll.setFont (new java.awt.Font ("Dialog", 0, 10));
      jB_RemoveAll.setText ("Remove All");
      jB_RemoveAll.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
              jB_RemoveAllActionPerformed (evt);
          }
      }
      );
  
      jP_Block_Set.add (jB_RemoveAll, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 160, 130, 20));
  
  
      jP_Block_Set.add (jTF_Initial_State, new org.netbeans.lib.awtextra.AbsoluteConstraints (90, 20, 50, 20));
  
  
      jP_Block_Set.add (jTF_Block_Size, new org.netbeans.lib.awtextra.AbsoluteConstraints (90, 50, 50, 20));
  
  
      jP_Block_Set.add (jTF_Quantity, new org.netbeans.lib.awtextra.AbsoluteConstraints (90, 80, 50, 20));
  

    add (jP_Block_Set, new org.netbeans.lib.awtextra.AbsoluteConstraints (10, 10, 150, 200));


      jTable.setModel (new javax.swing.table.DefaultTableModel (
      new Object [][] {
      {null, null, null}
      },
      new String [] {
          "Initial State", "Final State", "Block Size"
      }
      ) {
          Class[] types = new Class [] {
              java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class
          };
          boolean[] canEdit = new boolean [] {
              false, false, false
          };
  
          public Class getColumnClass (int columnIndex) {
              return types [columnIndex];
          }
  
          public boolean isCellEditable (int rowIndex, int columnIndex) {
              return canEdit [columnIndex];
          }
      });
      jTable.setFont (new java.awt.Font ("Dialog", 1, 10));
  
      jScrollPane1.setViewportView (jTable);
  

    add (jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints (170, 80, 260, 130));

    jL_Block.setText ("Blocks Defined");
    jL_Block.setFont (new java.awt.Font ("Dialog", 1, 10));


    add (jL_Block, new org.netbeans.lib.awtextra.AbsoluteConstraints (170, 60, -1, 20));

    jLabel1.setText ("Total Number of States");
    jLabel1.setFont (new java.awt.Font ("Dialog", 1, 10));


    add (jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints (170, 10, 160, 20));

    jLabel2.setText ("Covered States");
    jLabel2.setFont (new java.awt.Font ("Dialog", 1, 10));


    add (jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints (170, 35, 160, 20));

    jL_Total_States.setForeground (java.awt.Color.black);
    jL_Total_States.setHorizontalAlignment (javax.swing.SwingConstants.RIGHT);
    jL_Total_States.setFont (new java.awt.Font ("Dialog", 1, 10));
    jL_Total_States.setHorizontalTextPosition (javax.swing.SwingConstants.RIGHT);


    add (jL_Total_States, new org.netbeans.lib.awtextra.AbsoluteConstraints (340, 10, 90, 20));

    jPB_Covered_States.setString ("0");
    jPB_Covered_States.setStringPainted (true);
    jPB_Covered_States.setFont (new java.awt.Font ("Dialog", 1, 10));


    add (jPB_Covered_States, new org.netbeans.lib.awtextra.AbsoluteConstraints (340, 37, 90, -1));

}//GEN-END:initComponents

  private void jTF_Initial_StateActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTF_Initial_StateActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_jTF_Initial_StateActionPerformed







  private void jB_RemoveActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_RemoveActionPerformed

    int  selectedRow;

    while ((selectedRow = jTable.getSelectedRow()) >= 0 )
    {
      coveredStates -= ((Integer)jTable.getValueAt(selectedRow, 2)).intValue();

      ((javax.swing.table.DefaultTableModel)(jTable.getModel())).removeRow(selectedRow);


    }
    jPB_Covered_States.setValue(coveredStates);
    jPB_Covered_States.setString(String.valueOf(coveredStates));

  }//GEN-LAST:event_jB_RemoveActionPerformed

  private void jB_RemoveAllActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_RemoveAllActionPerformed


      ((javax.swing.table.DefaultTableModel)(jTable.getModel())).setNumRows(0);
      coveredStates = 0;

      jPB_Covered_States.setValue(coveredStates);
      jPB_Covered_States.setString(String.valueOf(coveredStates));

  }//GEN-LAST:event_jB_RemoveAllActionPerformed

  private void jB_AddActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_AddActionPerformed


    /* preliminar verifications */

    if (nStates <= 0) /* The chain was generated? .states exists? */
    {

      javax.swing.JOptionPane.showMessageDialog(this,"Error opening " + curmodel + ".states", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
      return;

    }

    if(T2functions.Is_some_field_missing(jP_Block_Set))
    {
      return;
    }

    int Initial_State = (new Integer(jTF_Initial_State.getText())).intValue();
    int Block_Size = (new Integer(jTF_Block_Size.getText())).intValue();
    int Quantity = (new Integer(jTF_Quantity.getText())).intValue();

    if (( Initial_State <= 0 ) || ( Initial_State > nStates) )
    {
      javax.swing.JOptionPane.showMessageDialog(this,"Invalid initial state.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
      return;
    }

    if (Block_Size <= 0)
    {
      javax.swing.JOptionPane.showMessageDialog(this,"Invalid block size.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
      return;
    }

    if ( Initial_State + Block_Size - 1 > nStates )
    {
      javax.swing.JOptionPane.showMessageDialog(this,"Invalid combination of initial state and size.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
      return;
    }

    if ( Quantity <= 0 )
    {
      javax.swing.JOptionPane.showMessageDialog(this,"Invalid number of blocks.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
      return;
    }

    /* registers insertion loop */


    int nRows = jTable.getRowCount(), is=0, row, j, nextBlock;

    for (row=0; row < nRows; row++)
    {

      is = ((Integer)jTable.getValueAt(row, 0)).intValue();

      if ( is >= Initial_State )
      {

        if ( is == Initial_State )
        {
          javax.swing.JOptionPane.showMessageDialog(this,"Block collision.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
          return;

        }

        break;
      }

    }

    if (row < nRows)

      nextBlock = is;

    else

      nextBlock = nStates + 1;


    if (row > 0)
    {

      if (Initial_State <= ((Integer)jTable.getValueAt(row-1, 1)).intValue())
      {
        javax.swing.JOptionPane.showMessageDialog(this,"Block collision.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return;

      }

    }


    for (j = 0; j < Quantity; j++)
    {

      if ( (Initial_State + Block_Size) < nextBlock)
      {

        ((javax.swing.table.DefaultTableModel)(jTable.getModel())).insertRow( row,
                              new Object[]
                              {
                                 new Integer(Initial_State),
                                 new Integer(Initial_State + Block_Size - 1),
                                 new Integer(Block_Size)
                              } );

        coveredStates += Block_Size;
      }
      else
      {
        Block_Size = nextBlock - Initial_State;

        if (Block_Size > 0)
        {
          ((javax.swing.table.DefaultTableModel)(jTable.getModel())).insertRow( row,
                              new Object[]
                              {
                                 new Integer(Initial_State),
                                 new Integer(Initial_State + Block_Size - 1), // final state
                                 new Integer(Block_Size)
                              } );
           coveredStates += Block_Size;
        }
        break;
      }


      row++;

      Initial_State += (Block_Size);

    }


    /* update of the progress bar */

    jPB_Covered_States.setValue(coveredStates);
    jPB_Covered_States.setString(String.valueOf(coveredStates));


  }//GEN-LAST:event_jB_AddActionPerformed


// Variables declaration - do not modify//GEN-BEGIN:variables
private javax.swing.JPanel jP_Block_Set;
private javax.swing.JLabel jL_Initial_State;
private javax.swing.JLabel jL_Block_Size;
private javax.swing.JButton jB_Add;
private javax.swing.JLabel jL_Quantity;
private javax.swing.JButton jB_Remove;
private javax.swing.JButton jB_RemoveAll;
private javax.swing.JTextField jTF_Initial_State;
private javax.swing.JTextField jTF_Block_Size;
private javax.swing.JTextField jTF_Quantity;
private javax.swing.JScrollPane jScrollPane1;
private javax.swing.JTable jTable;
private javax.swing.JLabel jL_Block;
private javax.swing.JLabel jLabel1;
private javax.swing.JLabel jLabel2;
private javax.swing.JLabel jL_Total_States;
private javax.swing.JProgressBar jPB_Covered_States;
// End of variables declaration//GEN-END:variables

  private void initComponentsManual() {

    nStates = 0;
    coveredStates = 0;
    nBlocks = 0;
    ((javax.swing.table.DefaultTableModel)(jTable.getModel())).removeRow(0);

    jTable.setSelectionMode(2);

    try {

        java.io.FileReader fr = new java.io.FileReader(curdir + "/" + curmodel + ".states");

        java.io.BufferedReader br = new java.io.BufferedReader(fr);

        while(br.readLine() != null)
          nStates++;

        br.close();

        fr.close();


    } catch (java.io.IOException e) {

         nStates = -1;

    }

    jPB_Covered_States.setMaximum(nStates);
    jPB_Covered_States.setMinimum(0);

    try {

       String line;

       int i,j, finalState, blockSize, initialState;

       java.io.FileReader fr = new java.io.FileReader(curdir + "/" + curmodel + ".partition");
       java.io.BufferedReader br = new java.io.BufferedReader(fr);

       nBlocks = (new Integer(br.readLine())).intValue();

       int lastState = 0, quantity;
       while (( line = br.readLine() ) != null)
       {

              i = line.indexOf(' '); i++;
              j = line.indexOf(' ', i); j++;

              finalState = (new Integer ( (line.substring(j)).trim())).intValue();
              blockSize =  (new Integer ( (line.substring(i,j)).trim())).intValue();

              if(finalState - blockSize < lastState)
                break;

              quantity = (finalState - lastState) / blockSize;

              initialState = lastState + 1;

              for(i = 0; i < quantity; i++)
              {
                coveredStates += blockSize;
                ((javax.swing.table.DefaultTableModel)(jTable.getModel())).addRow(
                              new Object[]
                              {
                                 new Integer(initialState),
                                 new Integer(initialState + blockSize - 1),
                                 new Integer(blockSize)
                              } );
                initialState += blockSize;
              }
              lastState = finalState;
       }


    }  catch (java.io.IOException e) {

       /* error reading .partition */

    }  catch (NumberFormatException e) {

       /* .partition may be empty */

    }

    jL_Total_States.setText(String.valueOf(nStates));

    jPB_Covered_States.setValue(coveredStates);
    jPB_Covered_States.setString(String.valueOf(coveredStates));
  }

  public void setEnabledComponents(boolean state)
  {
    jTF_Initial_State.setEnabled(state);
    jTF_Block_Size.setEnabled(state);
    jTF_Quantity.setEnabled(state);
    jB_Add.setEnabled(state);
    jB_Remove.setEnabled(state);
    jB_RemoveAll.setEnabled(state);
  }

  public boolean validateBlocks() {


    String line;

    int nRows =  jTable.getRowCount();

    int row, lookahead, curSize;

    /* validation */
    if (coveredStates < nStates)
    {
        javax.swing.JOptionPane.showMessageDialog(this,"The matrix isn't fully covered.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return (false);
    }
    else if (coveredStates > nStates)
    {
        System.out.println("There are more covered states than the matrix actual number of states.  Unable to generate .partition file.");
        return (false);
    }

    try {

      /* output generation */
      java.io.FileWriter fw = new java.io.FileWriter(curdir + "/" + curmodel + ".partition");
      java.io.BufferedWriter bw = new java.io.BufferedWriter(fw);

      /* write the number of blocks */

      line = String.valueOf( nRows );

      bw.write(line,0,line.length());

      bw.newLine();

      /* write the compressed block definitions */

      for (row = 0; row < nRows; row++)
      {
        lookahead = row+1;

        curSize = ((Integer)jTable.getValueAt(row,2)).intValue();

        while ( (lookahead < nRows) && ( ((Integer)jTable.getValueAt(lookahead,2)).intValue() == curSize )  )
        {
          lookahead++;
        }

        row = lookahead - 1;

        line = "s " + curSize + " " + ((Integer)jTable.getValueAt(row,1)) ;    /* s [size] [final_state] */

        bw.write(line,0,line.length());
        bw.newLine();
      }
      bw.close();
      fw.close();

    } catch (java.io.IOException e) {
        javax.swing.JOptionPane.showMessageDialog(this,"Couldn't generate .partition file.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return (false);
    }


    return (true);

  }


  private int nStates;
  private int nBlocks;
  private int coveredStates;


  private String curdir;
  private String curmodel;

}
