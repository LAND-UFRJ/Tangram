#include "HMMActions.h"

#include <stdio.h> 

#include <qmessagebox.h>
#include <qfiledialog.h>

HMMActions::HMMActions( QWidget *parent, Object *object )
           :QGroupBox( 100, Qt::Vertical, "HMM object actions", parent )
{
    main_window  = (MainWindow *)parent;
    this->object = object;
}

void HMMActions::buildInterface( void )
{
    tb_actions = new QTabWidget( this );
    
    buildViterbiFrame();
    buildLikelihoodFrame();
    buildForecastFrame();
    buildTrainFrame();    
    buildSimulateFrame();      
    buildLossRateFrame(); 
    buildStateProbabilityFrame();     
    buildSaveFrame();    

    hide();
}

void HMMActions::buildViterbiFrame( void )
{
    fm_viterbi         = new QFrame( this );
    viterbi_layout     = new QGridLayout( fm_viterbi, 3, 2, 5 );
    
    // Observations
    lbl_viterbi_obs    = new QLabel( "Observations source:", fm_viterbi );
    cb_viterbi_obs     = new ObjectsCombo( fm_viterbi, main_window );

    // States
    lbl_viterbi_states = new QLabel( "Hidden states storage:", fm_viterbi );
    cb_viterbi_states  = new ObjectsCombo( fm_viterbi, main_window );

    // Run
    bt_viterbi         = new QPushButton( "Run", fm_viterbi );
    connect( bt_viterbi, SIGNAL( clicked() ), 
             this, SLOT( runViterbi() ) );     
    
    // Build layout
    viterbi_layout->addWidget( lbl_viterbi_obs,     0, 0 ); 
    viterbi_layout->addWidget( cb_viterbi_obs,      0, 1 );
    viterbi_layout->addWidget( lbl_viterbi_states,  1, 0 ); 
    viterbi_layout->addWidget( cb_viterbi_states,   1, 1 );   
    viterbi_layout->addMultiCellWidget( bt_viterbi, 2, 2, 0, 1 );
    
    tb_actions->addTab( fm_viterbi, "Viterbi" );
    tb_actions->setTabToolTip( fm_viterbi,
           "Evaluates the most likely sequence of states for an observation" );
}

void HMMActions::buildLikelihoodFrame( void )
{
    fm_likelihood        = new QFrame( this );
    likelihood_layout    = new QGridLayout( fm_likelihood, 3, 2, 5 );           

    // Observations
    lbl_likelihood_obs   = new QLabel( "Observations source:", fm_likelihood );  
    cb_likelihood_obs    = new ObjectsCombo( fm_likelihood, main_window );    

    // States
    gb_likelihood_states = new QGroupBox( 1, Qt::Vertical,
                                          "Store states", fm_likelihood );
    gb_likelihood_states->setCheckable( true );
    gb_likelihood_states->setChecked( false );    
    cb_likelihood_states = new ObjectsCombo( gb_likelihood_states,
                                             main_window );

    // Run
    bt_likelihood        = new QPushButton( "Run", fm_likelihood );
    connect( bt_likelihood, SIGNAL( clicked() ), 
             this, SLOT( runLikelihood() ) );     
    
    // Build layout
    likelihood_layout->addWidget( lbl_likelihood_obs,     0, 0 ); 
    likelihood_layout->addWidget( cb_likelihood_obs,      0, 1 );
    likelihood_layout->addMultiCellWidget( gb_likelihood_states, 1, 1, 0, 1 );
    likelihood_layout->addMultiCellWidget( bt_likelihood,        2, 2, 0, 1 );
    
    tb_actions->addTab( fm_likelihood, "Likelihood" );
    tb_actions->setTabToolTip( fm_likelihood,
           "Calculates and displays the probability that a sample was\n"
           "generated by the current model parameter" );
}

void HMMActions::buildForecastFrame( void )
{
    fm_forecast        = new QFrame( this );
    forecast_layout    = new QGridLayout( fm_forecast, 3, 2, 5 );           
    
    // Observations
    lbl_forecast_obs   = new QLabel( "Observations source:", fm_forecast );  
    cb_forecast_obs    = new ObjectsCombo( fm_forecast, main_window );    

    // Forecasting Window
    lbl_forecast_wind     = new QLabel( "Size of forecasting window:", fm_forecast );
    sb_forecast_wind      = new QSpinBox( 1, INT_MAX, 1, fm_forecast );

    // Predictions
    gb_forecast_store  = new QGroupBox( 1, Qt::Vertical,
                                          "Store predictions", fm_forecast );
    gb_forecast_store->setCheckable( true );
    gb_forecast_store->setChecked( false );
    cb_forecast_store  = new ObjectsCombo( gb_forecast_store,
                                           main_window );
    // Run
    bt_forecast        = new QPushButton( "Run", fm_forecast );
    connect( bt_forecast, SIGNAL( clicked() ), 
             this, SLOT( runForecast() ) );     

    // Build layout    
    forecast_layout->addWidget( lbl_forecast_obs,     0, 0 ); 
    forecast_layout->addWidget( cb_forecast_obs,      0, 1 );
    forecast_layout->addWidget( lbl_forecast_wind,     1, 0 ); 
    forecast_layout->addWidget( sb_forecast_wind,      1, 1 );
    forecast_layout->addMultiCellWidget( gb_forecast_store, 2, 2, 0, 1 );
    forecast_layout->addMultiCellWidget( bt_forecast,       3, 3, 0, 1 );
    
    tb_actions->addTab( fm_forecast, "Forecast" );  
    tb_actions->setTabToolTip( fm_forecast,
           "Calculates and displays the emission distribution \n"
           "at each time step given some previous history." );
}

void HMMActions::buildTrainFrame( void )
{
    fm_train     = new QFrame( this );
    tb_train     = new QTabWidget( fm_train );
    train_layout = new QVBoxLayout( fm_train, 5 );

    // Build subframes        
    buildTrainFromObservationsFrame();
    buildTrainFromStatesFrame();

    // Run
    bt_train     = new QPushButton( "Run", fm_train );
    connect( bt_train, SIGNAL( clicked() ), 
             this, SLOT( runTrain() ) );

    train_layout->addWidget( tb_train );
    train_layout->addWidget( bt_train );    

    tb_actions->addTab( fm_train, "Training" );    
    tb_actions->setTabToolTip( fm_train,
           "Estimates a model's parameters by maximizing the likelihood of a sample.\n"
           "In the case of incomplete data (observations only) the Baum-Welch\n"
           "algorithm is used. Multiple observation samples can also be used" );
}

void HMMActions::buildTrainFromObservationsFrame( void )
{    
    fm_train_obs         = new QFrame( fm_train );
    train_obs_layout     = new QGridLayout( fm_train_obs, 3, 2, 5 );

    // Iterations
    lbl_train_obs_it     = new QLabel( "Number of iterations:", fm_train_obs );
    sb_train_obs_it      = new QSpinBox( 1, INT_MAX, 1, fm_train_obs );

    // Threshold
    gb_train_obs_thr     = new QGroupBox( 1, Qt::Vertical,
                                          "Log-likelihood threshold:",
                                          fm_train_obs );
    gb_train_obs_thr->setCheckable( true );
    gb_train_obs_thr->setChecked( false );    
    le_train_obs_thr     = new QLineEdit( gb_train_obs_thr );
    le_train_obs_thr->setText( "0.001" );

    // Observation sources
    gb_train_obs_obj_src = new QGroupBox( 1, Qt::Vertical,
                                          "Source objects:",
                                          fm_train_obs );
    fm_train_obs_obj_src     = new QFrame( gb_train_obs_obj_src );
    train_obs_obj_src_layout = new QGridLayout( fm_train_obs_obj_src, 3, 2, 5 );
    cb_train_obs_obj_src     = new ObjectsCombo( fm_train_obs_obj_src,
                                                 main_window );
    bt_train_obs_obj_src_add = new QPushButton( "Add", fm_train_obs_obj_src );
    connect( bt_train_obs_obj_src_add, SIGNAL( clicked() ), 
             this, SLOT( addObject() ) ); 
    bt_train_obs_obj_src_rm = new QPushButton( "Remove", fm_train_obs_obj_src );
    connect( bt_train_obs_obj_src_rm, SIGNAL( clicked() ), 
             this, SLOT( removeObject() ) );                  
    lb_train_obs_obj_src     = new QListBox( fm_train_obs_obj_src );
    
    // Build observation sources layout    
    train_obs_obj_src_layout->addWidget( cb_train_obs_obj_src,     0, 0 );
    train_obs_obj_src_layout->addWidget( bt_train_obs_obj_src_add, 1, 0 );
    train_obs_obj_src_layout->addWidget( bt_train_obs_obj_src_rm,  2, 0 );    
    train_obs_obj_src_layout->addMultiCellWidget( lb_train_obs_obj_src,
                                                  0, 2, 1, 1 );    

    // Build mainframe layout
    train_obs_layout->addWidget( lbl_train_obs_it, 0, 0 );
    train_obs_layout->addWidget( sb_train_obs_it,  0, 1 );    
    train_obs_layout->addMultiCellWidget( gb_train_obs_thr,     1, 1, 0, 1 );
    train_obs_layout->addMultiCellWidget( gb_train_obs_obj_src, 2, 2, 0, 1 );   

    tb_train->addTab( fm_train_obs, "From observations" );
}

void HMMActions::buildTrainFromStatesFrame( void )
{
    fm_train_st         = new QFrame( fm_train );
    train_st_layout     = new QGridLayout( fm_train_st, 2, 2, 5 );
    
    // Observations
    lbl_train_st_obs    = new QLabel( "Observations source:", fm_train_st );
    cb_train_st_obs     = new ObjectsCombo( fm_train_st, main_window );

    // States
    lbl_train_st_states = new QLabel( "States source:", fm_train_st );
    cb_train_st_states  = new ObjectsCombo( fm_train_st, main_window );
    
    // Build layout
    train_st_layout->addWidget( lbl_train_st_obs,     0, 0 ); 
    train_st_layout->addWidget( cb_train_st_obs,      0, 1 );
    train_st_layout->addWidget( lbl_train_st_states,  1, 0 ); 
    train_st_layout->addWidget( cb_train_st_states,   1, 1 );   

    tb_train->addTab( fm_train_st, "From states" );
}

void HMMActions::buildSimulateFrame( void )
{
    fm_simulate         = new QFrame( this );
    simulate_layout     = new QGridLayout( fm_simulate, 4, 2, 5 ); 
    
    // Steps
    lbl_simulate_sample = new QLabel( "Number of steps:", fm_simulate );
    sb_simulate_sample  = new QSpinBox( 1, INT_MAX, 1, fm_simulate );

    // Observations
    lbl_simulate_obs    = new QLabel( "Observations storage:", fm_simulate ); 
    cb_simulate_obs     = new ObjectsCombo( fm_simulate, main_window );    

    // States
    gb_simulate_store   = new QGroupBox( 1, Qt::Vertical,
                                          "Store states", fm_simulate );
    gb_simulate_store->setCheckable( true );
    gb_simulate_store->setChecked( false );
    cb_simulate_store   = new ObjectsCombo( gb_simulate_store,
                                            main_window );

    // Run
    bt_simulate         = new QPushButton( "Run", fm_simulate );
    connect( bt_simulate, SIGNAL( clicked() ), 
             this, SLOT( runSimulate() ) );     

    // Build layout
    simulate_layout->addWidget( lbl_simulate_sample,  0, 0 ); 
    simulate_layout->addWidget( sb_simulate_sample,   0, 1 );    
    simulate_layout->addWidget( lbl_simulate_obs,     1, 0 ); 
    simulate_layout->addWidget( cb_simulate_obs,      1, 1 );
    simulate_layout->addMultiCellWidget( gb_simulate_store, 2, 2, 0, 1 );
    simulate_layout->addMultiCellWidget( bt_simulate,       3, 3, 0, 1 );
    
    tb_actions->addTab( fm_simulate, "Simulate" );  
    tb_actions->setTabToolTip( fm_simulate,
        "Generates a random sample path from the model" );
}

void HMMActions::buildLossRateFrame( void )
{
    fm_loss_rate = new QFrame( this );

    loss_rate_layout = new QVBoxLayout( fm_loss_rate, 5 );
    
    gb_loss_rate_from_trace = new QGroupBox( 1, Qt::Vertical,
                                             "From observations",
                                             fm_loss_rate );
    gb_loss_rate_from_trace->setCheckable( true );
    gb_loss_rate_from_trace->setChecked( false );    
                                             
    fm_loss_rate_from_trace = new QFrame( gb_loss_rate_from_trace );
    loss_rate_from_trace_layout = new QGridLayout( fm_loss_rate_from_trace,
                                                   2, 2, 5 );
    // Observations
    lbl_loss_rate_src = new QLabel( "Observations source",
                                    fm_loss_rate_from_trace );
    cb_loss_rate_src  = new ObjectsCombo( fm_loss_rate_from_trace,
                                          main_window );
    
    // Future steps
    lbl_loss_rate_future_steps = new QLabel( "Future steps",
                                             fm_loss_rate_from_trace );
    sb_loss_rate_future_steps  = new QSpinBox( 1, INT_MAX, 1,
                                               fm_loss_rate_from_trace );

    // Build groubox layout
    loss_rate_from_trace_layout->addWidget( lbl_loss_rate_src,          0, 0 ); 
    loss_rate_from_trace_layout->addWidget( cb_loss_rate_src,           0, 1 ); 
    loss_rate_from_trace_layout->addWidget( lbl_loss_rate_future_steps, 1, 0 );
    loss_rate_from_trace_layout->addWidget( sb_loss_rate_future_steps,  1, 1 );
    
    // Run
    bt_loss_rate = new QPushButton( "Run", fm_loss_rate );
    connect( bt_loss_rate, SIGNAL( clicked() ), 
             this, SLOT( runLossRate() ) );     

    // Build frame layout
    loss_rate_layout->addWidget( gb_loss_rate_from_trace );
    loss_rate_layout->addWidget( bt_loss_rate );    

    tb_actions->addTab( fm_loss_rate, "Loss rate" );
    tb_actions->setTabToolTip( fm_loss_rate,
        "Evaluates the model prediction for steady state or transient\n"
        "loss rates." );    
}

void HMMActions::buildStateProbabilityFrame( void )
{
    fm_state_prob     = new QFrame( this );
    state_prob_layout = new QVBoxLayout( fm_state_prob, 5 );           

    // Observations
    gb_state_prob_obs = new QGroupBox( 1, Qt::Vertical,
                                       "From observations", fm_state_prob );
    gb_state_prob_obs->setCheckable( true );
    gb_state_prob_obs->setChecked( false );    
    
    cb_state_prob_obs = new ObjectsCombo( gb_state_prob_obs, main_window );    

    // Run
    bt_state_prob     = new QPushButton( "Run", fm_state_prob );
    connect( bt_state_prob, SIGNAL( clicked() ), 
             this, SLOT( runStateProbability() ) );     
    
    // Build layout
    state_prob_layout->addWidget( gb_state_prob_obs ); 
    state_prob_layout->addWidget( bt_state_prob );
    
    tb_actions->addTab( fm_state_prob, "State probability" );  
    tb_actions->setTabToolTip( fm_state_prob,
        "Evaluates the probability of each hidden state, which can be\n"
        "based on observations." );     
}

void HMMActions::buildSaveFrame( void )
{
    fm_save         = new QFrame( this );
    save_layout     = new QVBoxLayout( fm_save, 5 );    

    // Parameter options    
    bg_save_option  = new QVButtonGroup( "Parameter", fm_save );
    rb_save_all     = new QRadioButton( "All", bg_save_option );
    rb_save_pi      = new QRadioButton( "Initial state vector",
                                         bg_save_option );
    rb_save_A       = new QRadioButton( "State transition matrix",
                                         bg_save_option );
    rb_save_B       = new QRadioButton( "Observation symbol matrix",
                                         bg_save_option );
    // Default option is all parameters
    rb_save_all->setChecked( true );
    
    // File name
    gb_save_file    = new QGroupBox( 2, Qt::Horizontal,
                                     "File name", fm_save );
    le_save_file    = new QLineEdit( gb_save_file );
    bt_save_file    = new QPushButton( "Choose file", gb_save_file );
    connect( bt_save_file, SIGNAL( clicked() ), 
             this, SLOT( chooseSaveFile() ) );     
    bt_save         = new QPushButton( "Save", fm_save );
    connect( bt_save, SIGNAL( clicked() ), 
             this, SLOT( save() ) ); 

    save_layout->addWidget( bg_save_option );
    save_layout->addWidget( gb_save_file );
    save_layout->addWidget( bt_save      );
    
    tb_actions->addTab( fm_save, "Save" ); 
    tb_actions->setTabToolTip( fm_save,
        "Stores a model description or an individual parameter in a file" );
}

void HMMActions::runViterbi( void )
{
    Arguments args;
    Token     tk_object_obs, tk_object_states;

    tk_object_obs.type = TK_IDENTIFIER;
    tk_object_obs.text = cb_viterbi_obs->getObject();
    args.push_back( tk_object_obs );    

    tk_object_states.type = TK_IDENTIFIER;
    tk_object_states.text = cb_viterbi_states->getObject();
    args.push_back( tk_object_states );    

    object->exec( "viterbi", args );    
}

void HMMActions::runLikelihood( void )
{
    Arguments args;
    Token     tk_object_obs, tk_object_states;

    tk_object_obs.type = TK_IDENTIFIER;
    tk_object_obs.text = cb_likelihood_obs->getObject();
    args.push_back( tk_object_obs );    

    if( gb_likelihood_states->isChecked() )
    {
        tk_object_states.type = TK_IDENTIFIER;
        tk_object_states.text = cb_likelihood_states->getObject();
        args.push_back( tk_object_states ); 
    }

    object->exec( "likelihood", args );
}

void HMMActions::runForecast( void )
{
    Arguments args;
    Token     tk_object_forec_wind, tk_object_obs, tk_object_predictions;
    
    tk_object_forec_wind.type = TK_INTEGER;
    tk_object_forec_wind.text = sb_forecast_wind->text().ascii();
    args.push_back( tk_object_forec_wind );

    tk_object_obs.type = TK_IDENTIFIER;
    tk_object_obs.text = cb_forecast_obs->getObject();
    args.push_back( tk_object_obs );    

    if( gb_forecast_store->isChecked() )
    {
        tk_object_predictions.type = TK_IDENTIFIER;
        tk_object_predictions.text = cb_forecast_store->getObject();
        args.push_back( tk_object_predictions ); 
    }

    object->exec( "forecast", args );
}

void HMMActions::runTrain( void )
{
    Arguments args;
    bool status = true;
    
    switch( tb_train->currentPageIndex() )
    {
        // Only from observations
        case 0:
        {
            Token tk_it, tk_thr, tk_obj;
            
            tk_it.type = TK_INTEGER;
            tk_it.text = sb_train_obs_it->text().ascii();
            args.push_back( tk_it );
            
            if( gb_train_obs_thr->isChecked() )
            {
                tk_thr.type = TK_REAL;
                tk_thr.text = le_train_obs_thr->text().ascii();
                args.push_back( tk_thr );            
            }
            
            int n = lb_train_obs_obj_src->count();
            if( n == 0 )
            {
                QMessageBox::warning( 0, "No object selected",
                                      QString( "Please, select an object." ) );
                cb_train_obs_obj_src->setFocus();
                status = false;
            }
            else
            {
                for( int i = 0; i < n; i++ )
                {
                    tk_obj.type = TK_IDENTIFIER;
                    tk_obj.text = lb_train_obs_obj_src->text( i ).ascii();
                    args.push_back( tk_obj );
                }
            }
        }
        break;

        // From observations and states
        case 1:
        {
            Token tk_obs, tk_st;
            
            tk_obs.type = TK_IDENTIFIER;
            tk_obs.text = cb_train_st_obs->getObject();
            args.push_back( tk_obs );

            tk_st.type = TK_IDENTIFIER;
            tk_st.text = cb_train_st_states->getObject();
            args.push_back( tk_st );
        }
        break;
    }
    
    if( status )
        object->exec( "training", args );    
}

void HMMActions::addObject( void )
{
    lb_train_obs_obj_src->insertItem( cb_train_obs_obj_src->getObject() );
}

void HMMActions::removeObject( void )
{
    lb_train_obs_obj_src->removeItem( lb_train_obs_obj_src->currentItem() );
}

void HMMActions::runSimulate( void )
{
    Arguments args;
    Token     tk_samples, tk_object_obs, tk_object_states;

    tk_samples.type = TK_INTEGER;
    tk_samples.text = sb_simulate_sample->text().ascii();
    args.push_back( tk_samples );    

    tk_object_obs.type = TK_IDENTIFIER;
    tk_object_obs.text = cb_simulate_obs->getObject();
    args.push_back( tk_object_obs );    

    if( gb_simulate_store->isChecked() )
    {
        tk_object_states.type = TK_IDENTIFIER;
        tk_object_states.text = cb_simulate_store->getObject();
        args.push_back( tk_object_states ); 
    }

    object->exec( "simulate", args );
}

void HMMActions::runLossRate( void )
{
    Arguments args;
    Token     tk_src, tk_steps;
    
    if( gb_loss_rate_from_trace->isChecked() )
    {
        tk_src.type = TK_IDENTIFIER;
        tk_src.text = cb_loss_rate_src->getObject();
        args.push_back( tk_src );
        
        tk_steps.type = TK_INTEGER;
        tk_steps.text = sb_loss_rate_future_steps->text().ascii();
        args.push_back( tk_steps );                
    }
    
    object->exec( "loss_rate", args );    
}

void HMMActions::runStateProbability( void )
{
    Arguments args;
    Token     tk_src;
    
    if( gb_state_prob_obs->isChecked() )
    {
        tk_src.type = TK_IDENTIFIER;
        tk_src.text = cb_state_prob_obs->getObject();
        args.push_back( tk_src );
    }
    
    object->exec( "state_prob", args );
}

void HMMActions::chooseSaveFile( void )
{
    QString file = QFileDialog::getSaveFileName(
                                             main_window->getCurrentDir(),
                                            "Text files (*.txt);;All files (*)",
                                             this,
                                            "open file dialog",
                                            "Choose a file" );
    if( file != "" )
    {
        le_save_file->setText( file );
        
        main_window->setCurrentDir( file );
    }
}

void HMMActions::save( void )
{
    if( le_save_file->text() == "" )
    {
        QMessageBox::warning( 0, "No file selected",
                              QString( "Please, select a file to save." ) );
    }
    else
    {
        Arguments args;
        Token file, param;

        /* Building filename */
        file.type = TK_STRING;
        file.text = le_save_file->text().ascii();
        args.push_back( file );
        
        switch( bg_save_option->selectedId() )
        {
            case 0:
                param.type = TK_STRING;
                param.text = QString( "all" ).ascii();
                args.push_back( param );
                object->exec( "save", args ); 
                break;

            case 1:
                param.type = TK_STRING;
                param.text = QString( "pi" ).ascii();
                args.push_back( param );
                object->exec( "save", args ); 
                break;

            case 2:
                param.type = TK_STRING;
                param.text = QString( "A" ).ascii();
                args.push_back( param );
                object->exec( "save", args ); 
                break;          
                
            case 3:
                param.type = TK_STRING;
                param.text = QString( "B" ).ascii();
                args.push_back( param );
                object->exec( "save", args ); 
                break;                      
        }    
    }
}
